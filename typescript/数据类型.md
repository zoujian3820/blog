<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [typescript基础类型](#typescript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B)
    - [number类型](#number%E7%B1%BB%E5%9E%8B)
    - [string类型](#string%E7%B1%BB%E5%9E%8B)
    - [枚举类型](#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B)
    - [数组类型](#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B)
    - [元组类型](#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B)
    - [any类型](#any%E7%B1%BB%E5%9E%8B)
    - [void类型](#void%E7%B1%BB%E5%9E%8B)
    - [nerver类型](#nerver%E7%B1%BB%E5%9E%8B)
    - [object类型](#object%E7%B1%BB%E5%9E%8B)
    - [declare声明关键字](#declare%E5%A3%B0%E6%98%8E%E5%85%B3%E9%94%AE%E5%AD%97)
    - [类型断言](#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80)
    - [接口](#%E6%8E%A5%E5%8F%A3)
    - [函数的类型](#%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B)
      - [函数声明](#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E)
      - [函数表达式](#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F)
      - [用接口定义函数的形状](#%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E7%8A%B6)
      - [可选参数](#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0)
      - [剩余参数](#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0)
      - [重载](#%E9%87%8D%E8%BD%BD)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# typescript基础类型

**typescript**微软出品，javascript的超集

[TOC]
### number类型

``` typescript
let num: number = 123
num = 'sss' // error
```

### string类型

``` typescript
let str: string = 'str'
str = 22 // error
```

### 枚举类型

``` typescript
// 默认值如下：
enum Color {
    Red, // default 0
    Blue, // default 1
    Yellow // default 2
}
// 也可自己设定值：
enum Color {
    Red = 1,
    Blue = 3,
    Yellow = 25
}
let c:number = Color.Red
let c:string = Color[1]

// 转成js
var Color;
(function(){
    Color[Color['Red'] = 1] = 'Red';
    Color[Color['Blue'] = 3] = 'Blue';
    Color[Color['Yellow'] = 25] = 'Yellow';
})(Color || (Color = {}))

```

### 数组类型

``` typescript
let ary1: number[] = [1, 2, 3]
// 数组泛型写法
let ary2: Array<string> = ['a', 'str', 'c']
```

### 元组类型

``` typescript
let ary: [string, number]
ary = ['str', 123]
ary = [123, 'str'] // error 规定的顺序错了
ary = [true, 123] // error 因为元组严格按照规定的数据类型来设值，以上为string | number两种，也就是联合类型
ary[0] // str
ary[0].substr(0, 1) // s
ary[1].substr(0, 1) // error 数字没有substr方法
ary[2] // 元组中没有第2个元素，ts版本3.1及以上越界会报错
```

### any类型

>就是不确定数据的类型时可以使用，
它可以为任意数据类型

``` typescript
let notSure: any = 4
    noSure = 'ha ha ha'
    noSure = true

let list: any[] = [123, 'str', false]
```

### void类型

``` typescript
function warn(): void {
    console.log('this is void')
}
let unusable: void
unusable = false // error 因为void只能赋值 null | undefined
unusable = null
unusable = undefined
```

### nerver类型

>没有返回值的类型, 不能返回不能结束

``` typescript
// 第一种情况
function error(msg: string): nerver {
    throw new Error(msg)
}
function fail() {
    return error('ha ha')
}
// 第二种情况
function inifiniteLoop(): never {
    while (true) {

    }
}
```

### object类型

``` typescript

```

### declare声明关键字
>当使用第三方的库时，我们就需要引用它的声明文件
``` typescript
declare let jQuery: (selector: string) => any;
jQuery('.content')

declare function create(o: object | null): void;

create({prop: 123})
create(null)
create(123) // error
create(false) // error
create(undefined) // error

```

### 类型推断

``` typescript
let someVal: any = 'straa'
someVal.length
/*
undefined 无length属性，因为any类型，也就是可能是任何类型，不做类型推断
可借用类型断言，强制为string类型
*/
let str: number = (<string>someVal).length // 5
let str2: number = (someVal as string).length // 5


let str = 'ha ha'
str = 233 // error 类型推断为string，不可设number
```

### 类型断言

``` typescript
let someVal: any = 'straa'
someVal.length
/*
undefined 无length属性，因为any类型，也就是可能是任何类型，不做类型推断
可借用类型断言，强制为string类型
以下为类型断言两种写法：
*/
let str: number = (<string>someVal).length // 5
let str2: number = (someVal as string).length // 5
```

### 接口

``` typescript
interface Person {
    age: number; // 默认属性，必须添加, 且值为number
    name?: string; // 可选属性，可不添加
    readonly sex: string; // 只读属性，不可修改, 必须添加
    [propName: string]: any; // 任意属性，可添加任意属性 string | number，任意值
    // [propName: string]: string; // 返回值为string, 则所有其他属性返回值都只能为string，否则报错, 且可选属性会出错
}
let p: Person = {age: 2, sex: 'F', xxddd: false}
p.sex = 'M' // error
p.age = '' // error
p.bbbbbbbbbb = {}

let a:Person = {name: 'dd'} // error 少了age 和 sex
```
### 函数的类型

>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：

#### 函数声明
``` typescript
// 函数声明（Function Declaration）
function sum(x, y) {
    return x + y;
}

// 函数表达式（Function Expression）
let mySum = function (x, y) {
    return x + y;
};
```

一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：

``` typescript
function sum(x: number, y: number): number {
    return x + y;
}
```

注意，输入多余的（或者少于要求的）参数，是不被允许的：

``` typescript
function sum(x: number, y: number): number {
    return x + y;
}
sum(1, 2, 3);

// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.
function sum(x: number, y: number): number {
    return x + y;
}
sum(1);

// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.
```
#### 函数表达式

``` typescript
let mySum = function (x: number, y: number): number {
    return x + y;
};
```
这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：
``` typescript
let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
    return x + y;
};
```
注意不要混淆了 TypeScript 中的 => 和 ES6 中的 =>
在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型
在 ES6 中，=> 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数

#### 用接口定义函数的形状

我们也可以使用接口的方式来定义一个函数需要符合的形状：

``` typescript
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}

interface Hax {
    name: string;
    readonly age: number;
    address?: string;
    [propName: string]: any;
}

let hax = function(arg: Hax): Hax{
    return {
        name: '小明',
        age: 18
    }
}

```
#### 可选参数

前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？
与接口中的可选属性类似，我们用 ? 表示可选的参数：
``` typescript
function buildName(firstName: string = 'hahahah', lastName?: string) {
    if (lastName) {
        return firstName + ' ' + lastName;
    } else {
        return firstName;
    }
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName('Tom');

//需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了：

function buildName(firstName?: string, lastName: string) {
    if (firstName) {
        return firstName + ' ' + lastName;
    } else {
        return lastName;
    }
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName(undefined, 'Tom');

// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.
```

#### 剩余参数
ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）：

``` typescript
function push(array, ...items) {
    items.forEach(function(item) {
        array.push(item);
    });
}

let a = [];
push(a, 1, 2, 3);
// 事实上，items 是一个数组。所以我们可以用数组的类型来定义它：

function push(array: any[], ...items: any[]) {
    items.forEach(function(item) {
        array.push(item);
    });
}

let a = [];
push(a, 1, 2, 3);
// 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 ES6 中的 rest 参数。
```

#### 重载

``` typescript
function reverse (a: number): number;
function reverse (a: string): string;
function reverse(a: number | string) {
    if (typeof a === 'number') {
        return Number(a.toString().split('').reverse().join(''));
    } else if (typeof a === 'string') {
        return a.split('').reverse().join('');
    }
}
```